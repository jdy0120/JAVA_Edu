제네릭(generic)
 - jdk1.5에서 추가된 문법으로 현재는 필수로 사용되고 있음
 - 입력받을 자료형에 대한 지정을 위해 사용되는 문법
    기본적으로 Object형 즉, 모든 종류의 데이터를 받을 때 사용할 데이터의 자료형을 필요할 때 지정하는 방법
    클래스에 전체적으로 지정하거나, 메소드에 한해 지정하는 방법이 있음


컬레션 프레임웍(Collection Framework)
 - java.util 패키지에 있는 기능(클래스)들
 - 여러 데이터를 한 번에 저장하는 클래스들을 표준화시킨 설계를 의미
 - 컬렉션 프레임웍에는 Collection을 상속받는 List와 Set, 그리고 Collection을 상속받지 않는 Map의 세 가지가 존재
 - List : 순서가 있는 데이터의 집합으로 데이터의 중복을 허용
 - Set : 순서가 없는 데이터의 집합으로 데이터의 중복을 허용하지 않음
 - Map : 키(Key)와 값(value)의 쌍으로 이루어진 데이터 집합
 - 모든 컬렉션들의 입력받는 데이터의 자료형은 기본적으로 Object이다.
    Object이므로 입력받을 때는 아무 자료형이 받아도 됨
    단, 사용시 하위클래스의 메소드를 사용하려면 오버라이딩이나 하위클래스로 형변환을 해야 하므로 불편한 부분이 있음
    오버라이딩은 Object클래스에 존재하는 메소드를 이용해야 하는 데 메소드가 얼마 없기 때문에 보통은 하위클래스로의 형변환을 주로 하게 됨

Collection<E> 인터페이스
 - List와 Set의 상위클래스의 역할을 하며, 컬렉션 전체에서 공용으로 사용할 수 있는 메소드가 선언되어 있음
 - 제네릭으로 저장할 데이터의 자료형을 지정할 수 잇음
    지정하지 않으면 기본적으로 Object가 지정됨
 - 주요 메소드
리턴		메소드명 및 설명
boolean		add(E e) : 지정된 객체를 저장한 후 저장 성공여부를 리턴
boolean		addAll(Collection<? extends E> c) : E를 상속받는 자료형을 가진 Collection의 전부를 저장
void		clear() : 모든 요소들을 삭제
boolean		contains(Object o) : 지정한 객체(o)가 컬렉션에 포함되어 있는지 여부를 리턴
boolean		equals(Object o) : 같은 컬렉션이 있는지 여부
boolean		isEmpty() : 컬렉션이 비어있는지 여부
Iterator<E>	iterator() : 컬렉션의 iterator를 리턴
boolean		remove(Object o) : 지정된 객체를 찾아 삭제
boolean		removeAll(Collection<?> c) : 지정된 컬렉션에 포함된 객체들을 삭제
boolean		retainAll(Collection<?> c) : 지정된 컬렉션에 포함된 객체들을 제외한 나머지 삭제
int		size() : 컬렉션에 들어있는 객체의 개수
Object[]	toArray() : 컬렉션에 들어있는 객체들을 Object형 배열로 리턴
<T> T[]		toArray(T[] a) : 지정한 배열(a)에 컬렉션의 객체들을 담아 배열로 리턴

List<E> 인터페이스
 - public interface List<E> extends Collection<E> 로 선언된 인터페이스
 - 저장순서가 유지되면서 중복 데이터를 허용하는 컬렉션
 - 주요 메소드 : Collection에 있는 메소드는 제외
리턴		메소드명 및 설명
void		add(int index, E element) : 지정한 위치(index)에 객체(element)를 삽입
boolean		addAll(Collection<? extends E> c) : 지정한 위치(index)에 E를 상속받는 자료형을 가진 Collection의 전부를 저장
E		get(int index) : 리스트에서 지정한 위치의 객체를 리턴
int		indexOf(Object o) : 리스트에서 지정한 객체의 위치를 리턴, 못 찾으면 -1을 리턴
int		lastIndexOf(Object o) : indexOf()와 같으나 뒤에서 부터 찾기 시작
ListIterator<E>	listIterator() : 리스트의 ListIterator를 리턴
E		remove(int index) : 지정한 위치의 객체를 삭제한 후 객체를 리턴
E		set(int index, E element) : 지정한 위치(index)에 객체(element)를 저장, 기존의 위치에 있는 객체는 삭제됨
List<E>		subList(int fromIndex, int toIndex) : 리스트를 fromIndex, int toIndex -1까지 잘라내어 List로 리턴

ArrayList<E> 클래스
 - List인터페이스를 implements하는 클래스로 컬렉션 프레임웍에서 가장 많이 사용됨
 - 예전의 Vector를 개선한 것으로 될 수 있으면 Vector가 아닌 ArrayList를 사용해야 함
 - List이므로 저장순서를 기여하며(인덱스 사용), 중복된 데이터를 허용함
 - 생성자
ArrayList() : 기본 크기 10인 ArrayList 생성
ArrayList(Collection<? extends E> c) : 지정된 컬렉션을 이용하여 ArrayList 생성
ArrayList(int initialCapacity) : 지정한 초기용량을 가지는 ArrayList 생성
 : Collection을 상속받는 모든 List와 Set의 컬렉션들이 ArrayList로 생성될 수 있다는 의미

 - 주요 메소드 : Colection과 list에 있는 메소드는 제외
리턴	메소드명 및 설명
void	ensureCapacity(int minCapacity) : minCapacity를 최소 용량으로 지정
void	trimToSize() : 용량을 크기에 맞게 줄여줌(빈 공간을 삭제)


LinkedList 클래스
 - ArrayList다음으로 많이 사용되는 List 중 하나
 - ArrayList에 비해 데이터의 추가 및 삭제가 빠름 : 변화가 많은 컬렉션일 경우 ArrayList보다 효율적 
    데이터를 읽어 들이는 시간(접근 시간)이 느리며, 데이터가 많을 수록 접근성은 더 떨어짐
    순차적인 추가/삭제는 오히려 ArrayList가 더 빠름
    데이터의 개수가 변하지 않으면 ArrayList가 더 효율적이고, 변화가 많으면 LinkedList가 더 효율적

 - 생성자
LinkedList() : 빈 LinkedList를 생성
LinkedList(Collection<? extends E> c) : 지정한 컬렉션을 새로운 LinkedList로 생성

 - Queue<E> 인터페이스의 메소드
리턴		메소드명 및 설명
E		element() : 리스트의 첫번째 요소를 리턴
boolean		offer(E e) : 리스트의 끝에 지정된 객체를 추가
E		peek() : 리스트의 첫번째 요소를 리턴 - element()와 동일
E		poll() : 리스트의 첫번재 요소를 리턴 - 리스트에서 제거

 - 주요 메소드 : Collection과 list에 있는 메소드는 제외
 - Deque<E> 인터페이스의 메소드
리턴		메소드명 및 설명
void		addFirst(E e) : 리스트의 첫부분에 객체 추가
void		addLast(E e) : 리스트의 끝부분에 객체 추가
Iterator<E>	descendingIterator() : 내림차순으로 정렬하기 위한 iterator를 리턴
E		getFirst() : 첫번째 요소를 리턴
E		getLast() : 마지막 요소를 리턴
boolean		offerFirst(E e) : 리스트의 맨 앞에 지정된 객체를 추가
boolean		offerLast(E e) : 리스트의 맨 끝에 지정된 객체를 추가
E		peekFirst() : 리스트의 첫번째 요소를 리턴 - peek()와 동일
E		peekLast() : 리스트의 마지막 요소를 리턴
E		pollFirst() : poll()과 동일
E		pollLast() : 리스트의 마지막 요소를 리턴 - 리스트에서 제거
E		pop() : 리스트의 첫번째 요소를 삭제
void		push(E e) : addFirst()와 동일
E		removeFirst() : 리스트의 첫번째 요소를 삭제
E		removeLast() : 리스트의 마지막 요소를 삭제
boolean		removeFirstOccurrence(Object o) : 리스트에서 지정한 객체와 동일한 객체들 중 첫번째를 삭제
boolean		removeLastOccurrence(Object o) : 리스트에서 지정한 객체와 동일한 객체들 중 마지막번째를 삭제


Stack<E> 클래스
 - Vector를 상속받은 클래스로 처음 저장한 객체가 가장 나중에 나오는 구조로 되어 있다.
 - FILO(First In Last Out) 또는 LIFO(Last In First Out)
 - 생성자
Stack() : 빈 스택 생성
 - 주요 메소드
리턴		메도스명 및 설명
boolean		empty() : 비어있는지 여부를 리턴
E		peek() : 맨 위에 있는 데이터 리턴, 삭제는 안 함(없을 때 EmptyStackException발생)
E		pop() :맨 위에 있는 데이터 리턴, 리턴 후 삭제(없을 때 EmptyStackException발생)
E		push(E item) : 스텍에 지정한 객체를 저장
int		search(Object o) : 지정된 객체의 위치를 리턴(0이 아닌 1부터 시작), 못 찾으면 -1 리턴

Queue<E> 인터페이스
 - Collection인터페이스를 상속받는 인터페이스로 먼저 저장된 객체가 먼저 나오는 구조
 - FIFO(First In First Out) 또는 LILO(Last In Last Out)
 - Queue를 구현한 클래스인 LinkedList를 이용하여 작업하는 경우가 많다.
 - 생성자와 메소드는 LinkedList의 것을 사용하면 됨(Collection인터페이스의 메소드 포함)
 - 